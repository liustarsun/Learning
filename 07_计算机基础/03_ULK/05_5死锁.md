# 1. 概念
由于竞争资源或者通信关系，两个或更多线程在执行中出现，永远相互等待只能由其他进程引发的事件

# 2. 进程访问资源的流程
资源类型R1，R2....Rn，即CPU, 内存空间，IO设/备等等, 每类资源Ri都有Wi个实例
1. 请求/获取资源：申请空闲资源
2. 使用/占用资源：占用资源
3. 释放资源：资源的状态由占用变成空闲

## 2.1 资源分类
1. **可重用资源**
- 资源不能被删除，且任意时刻只能有一个进程在使用
- 释放后，其他进程可以使用
- 包括：
> 软件：文件，数据库，信号量等数据结构      
> 硬件：CPU，I/O通道，存储器，设备等      

- **可能会出现死锁**：进程占着资源，然后申请不到其他资源

2. **消耗资源**
- 资源的创建和销毁
- 包括：I/O缓冲区的中断，信号，消息等等 
- **可能出现死锁**：进程间相互等待对方的消息      

## 2.2 资源分配图
描述资源和进程之间的关系的有向图       

**两类顶点**：
所有进程：
P = {P1, P2.....Pn}

所有资源：       
R = {R1, R2.....Rm}

**两类有向边**：
资源请求边：          
进程Pi请求资源Rj：Pi===>Rj

资源分配边：
资源Rj给Pi分配资源：Rj===>Pi

Pi已经占用了Rj的一个实例

## 2.3 出现死锁的必要条件
**互斥**：任何时刻只能有一个进程使用一个实例        
**持有并等待**：进程持有一个资源，并且等待其他进程拥有的资源      
**非抢占**：资源只能进程使用结束后，自动释放     
**循环等待**：存在等待进程集合{P0，P1......Pn}     
P0等待P1的资源, P1等待P2的资源.....Pn等待P0的资源      


## 2.4 死锁解决方案
1. 死锁预防
采用某种策略，限制并发进程对资源的请求，使系统在任何时候都不满足死锁的必要条件        
**互斥**：把互斥的共享资源封装成可同时访问        
**持有并等待**：进程请求资源时，确保不持有任何资源；只允许进程在开始的时候，一次请求所有的资源，但是会导致资源利用率低       
**非抢占**：进程的请求，不能立即分配资源，则释放自己手里的资源；只在能一次性获得所有资源的时候，才分配资源     
**循环等待**：对资源排序，进程按照顺序申请资源                               

2. 死锁避免
在使用前进行判断，只允许不会出现死锁的进程申请资源         
要求进程声明需要资源的最大数目，限定提供和分配的资源数量，确保满足进程的最大需求；动态检查资源分配状态，确保不会出现环形等待               


3. 死锁检测和恢复
在检测的系统进入死锁状态后，进行恢复

4. 由应用程序处理死锁

5. 系统资源分配的安全状态
当进程请求资源时，判断分配后是否处于安全状态         
系统处于安全状态        
1. 针对所有已占用进程，存在安全序列
2. 安全序列<P1, P2...Pn>：
   Pi要求的资源<=当前可用资源+所有Pj持有的资源，其中j<i;       
   如果Pi的资源请求不能立即分配，则Pi等所有Pj完成，释放其资源;       
   Pi完成后，P(i+1)可得到所需资源，执行并释放所分配的资源;         
   最终整个序列的所有Pi都能获得所有的资源

3. 系统处于安全状态，一定没有死锁；系统处于不安全状态，可能会出去死锁==>避免死锁就是确保系统不进入不安全状态

## 2.5 银行家算法==>避免死锁
### 1. 背景
在银行中，客户申请贷款的数量是有限的，每个客户在第一次申请贷款时要声明完成该项目所需的最大资金量，在满足所有贷款要求时，客户应及时归还。银行家在客户申请的贷款数量不超过自己拥有的最大值时，都应尽量满足客户的需要。在这样的描述中，银行家就好比操作系统，资金就是资源，客户就相当于要申请资源的进程===>**核心就是客户要知道并通知银行家他需要多少，而银行家要确保客户要求的不超过自己拥有的最大值**        

### 2. 进程
进程 | 已占有 | 共需要 | 空闲可用 |
--- | --- | --- | --- |
P1 | A(0)B(0)C(1)D(4) | A(0)B(6)C(5)D(6) | A(1)B(5)C(2)D(0) |
P2 | A(1)B(4)C(3)D(2) | A(1)B(9)C(4)D(2) |  |
P3 | A(1)B(3)C(5)D(4) | A(1)B(3)C(5)D(6) |  |
P4 | A(1)B(0)C(0)D(0) | A(1)B(7)C(5)D(0) |  |

#### A.先判断是否是安全的
**共需要的-已占有的=还需要分配的**==>获取还需要分配表            
进程 | 还需要分配的
--- | ---
P1 | A(0)B(6)C(4)D(2)
P2 | A(0)B(5)C(1)D(0)
P3 | A(0)B(0)C(0)D(2)
P4 | A(0)B(7)C(5)D(0)

**然后加一个全为FALSE的字段==>完成分配**      
完成分配| 
---   |
FALSE | 
FALSE |
FALSE |
FALSE |

**把空闲可用的和各个进程需要的进行比较，找出需要的比空闲的小的==>要所有的资源都满足==>找到的是P2**     

#### B. 分配给P2，然后执行完P2，回收它的所有资源，此时可用的为
空闲可用| 
---   |
A(2)B(9)C(5)D(2)| 

**更改P2对应的完成分配字段**
完成分配| 
---   |
FALSE | 
TRUE |
FALSE |
FALSE |

**接着比较==>执行P3**
#### C. 分配给P3，执行P3，然后回收，此时可用为
空闲可用| 
---   |
A(3)B(12)C(10)D(6)| 

**更改P3对应的完成分配字段**
完成分配| 
---   |
FALSE | 
TRUE |
TRUE |
FALSE |

#### D. 依此类推，做完P4→P1，当全部的FINISH都变成true时，就是安全状态

### 3. 安全和不安全状态
如果所有过程有可能完成执行(终止)，则一个状态(如上述范例)被认为是安全的。由于系统无法知道什么时候一个过程将终止，或者之后它需要多少资源，**系统假定所有进程将最终试图获取其声明的最大资源并在不久之后终止**。在大多数情况下，这是一个合理的假设，因为系统不是特别关注每个进程运行了多久(至少不是从避免死锁的角度)。此外，如果一个进程终止前没有获取其它能获取的最多的资源，它只是让系统更容易处理。

基于这一假设，该算法通过尝试寻找允许每个进程获得的最大资源并结束(把资源返还给系统)的进程请求的一个理想集合，来决定一个状态是否是安全的。**不存在这个集合的状态都是不安全的**

### 4. 伪代码
```
// P-进程的集合
// Mp-进程p的最大的请求数目
// Cp-进程p当前被分配的资源
// A-当前可用的资源
while (P != ∅) {
    found = FALSE;
    foreach (p ∈ P) {
        if (Mp − Cp ≤ A) {
             /* p可以获得他所需的资源。假设他得到资源后立即执行；执行终止后，释放拥有的资源 */
             A = A + Cp ;
             P = P − {p};
             found = TRUE;
        }
    }
    if (! found) return FAIL;
}
return OK;
```