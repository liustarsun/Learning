# 1. 切换
进程切换也叫上下文切换，CPU资源的当前占用者切换，包括：
1. 暂停当前运行进程，从运行状态变成其他状态：保存当前进程在PCB中的执行上下文(CPU状态)    
2. 调度另一个进程从就绪状态变成运行状态：恢复下一个进程的执行上下文
   
## 1.1 要求
1. 切换前，保存进程上下文
2. 切换后，恢复进程上下文
3. 快速切换

## 1.2 进程生命周期的信息
1. 寄存器 (PC, SP, …)
2. CPU状态
3. 内存地址空间

## 1.3 TSS段
1. TSS反映了CPU上当前进程的特权级，每个CPU一个TSS，因此每个进程描述符在切换出去的时候，进程的上下文硬件会保存在这个结构中，包括大多数的CPU寄存器，但是不包括通用寄存器

## 1.4 切换流程 
1. 切换页全局目录表，目的是安装一个新的地址空间
2. 切换到内核态的栈和硬件上下文，因为硬件上下文提供了内核执行新进程所需要的所有信息，包括CPU寄存器
3. 任何进程切换中，**涉及到的是3个进程而不是2个进程**

------
# 调度

## 1. 概念
进程调度：
1. 从就绪队列中挑选下一个占用CPU运行的进程
2. 从多个可用CPU中挑选就绪进程可使用的CPU资源

调度程序：挑选就绪进程的内核函数，需要考虑
1. 调度策略：依据什么原则挑选进程/线程？
2. 调度时机：什么时候进行调度？

## 2. 调度时机
内核运行调度程序的条件：
1. 在进程/线程的生命周期中的什么时候进行调度？进程从运行状态切换到等待状态或者进程被终结了
2. 非抢占系统：当前进程主动放弃CPU时，时间片完了，或者出错等
3. 可抢占系统：中断请求被服务例程响应完成时；当前进程被抢占：进程时间片用完或者进程从等待切换到就绪

------
## 3. 调度策略
- 确定如何从就绪队列中选择下一个执行进程

- 要解决什么问题：
挑选就绪队列中的哪一个进程？通过什么样的准则来选择？

- 调度算法：
在调度程序中实现的调度策略

### 比较调度算法的准则
哪一个策略/算法较好?      
1. CPU使用率：CPU处于忙状态的时间百分比
2. 吞吐量：单位时间内完成的进程数量
> 减少开销（操作系统开销，上下文切换）      
> 系统资源的高效利用（CPU，I/O设备）      
> 减少每个进程的等待时间       

3. 周转时间：进程从初始化到结束(包括等待)的总时间 ===> 包括等待的时间
4. 等待时间：进程在就绪队列中的总时间
5. 响应时间：从提交请求到产生响应所花费的总时间
> 减少响应时间: 及时处理用户的输入请求，尽快将输出反馈给用户       
> 减少平均响应时间的波动: 在交互系统中，可预测性比高差异低平均更重要      
> 响应时间是操作系统的计算延迟

6. 调度算法的要求：希望“更快”的服务
7. 什么是更快？传输文件时的**高带宽**，调度算法的**高吞吐量**; 玩游戏时的**低延迟**，调度算法的**低响应延迟**
> 这两个因素是独立的

8. 与水管的类比: 低延迟：喝水的时候想要一打开水龙头水就流出来; 高带宽：给游泳池充水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟
9. 公平性目标: 保证每个进程占用相同的CPU时间===> 是否公平？ 保证每个进程的等待时间相同？
> 公平通常会增加平均响应时间   

### 调度算法
#### 1. 先来先服务===> 不公平，平均等待时间较差
依据进程进入就绪状态的先后顺序排列：进程进入等待或结束状态时，**就绪队列**中的下一个进程占用CPU
> 总的时间取决于等待时间的长短

**优点**：
简单      

**缺点**：
平均等待时间波动较大：短进程可能排在长进程后面      
I/O资源和CPU资源的利用率较低：CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也等待      

#### 2. 短进程优先===> 不公平，平均周转时间最小；需要精确的预测计算时间；可能导致饥饿
选择就绪队列中执行时间最短进程占用CPU进入运行状态(SPN)：就绪队列按预期的执行时间来排序
短剩余时间优先算法(SRT)：SPN算法的可抢占改进       

**优点**:
**短进程优先算法具有最优平均周转时间**

**缺点**:
导致饥饿：连续的短进程流会使长进程无法获得CPU资源      
需要预知未来：如何预估下一个CPU计算的持续时间？===> 为何需要预知未来


#### 3. 最高响应比优先===> 基于SPN调度；不可抢占
选择就绪队列中响应比R值最高的进程：Ｒ＝（ｗ+s)/s ===> w: 等待时间(waiting time) s: 执行时间(service time)
在短进程优先算法的基础上改进; 不可抢占; 关注进程的等待时间; 防止无限期推迟;


#### 4. 时间片轮转 ===> 公平，但是平均等待时间较差
分配处理机资源的基本时间单元: 时间片结束时，按FCFS算法切换到下一个就绪进程; 每隔(n – 1)个时间片进程执行一个时间片q
重点在如何选择时间片长度？
额外的上下文切换      
时间片太大：等待时间过长；极限情况退化成FCFS        
时间片太小：反应迅速，但产生大量上下文切换；大量上下文切换开销影响到系统吞吐量      
时间片长度选择目标：===> 经验规则：维持上下文切换开销处于1%以内        

#### 5. 多级反馈队列(MLFQ) ===> 多种算法的集成
就绪队列被划分成多个独立的子队列：如前台(交互)，后台(批处理)       
每个队列拥有自己的调度策略：前台(RR)，后台(FCFS)        
队列间的调度：
1. 固定优先级：先前台，然后处理后台，缺点是可能导致饥饿        
2. 时间片轮转：80%处理前台，20%处理后台       

多级反馈队列：进程可以在不同队列间移动的多级反馈队列
1. 时间片大小随着优先级增加而增加      
2. 如果当前时间片没有完成，则降到下一个优先级

**特点**：
CPU密集型下降的很快，I/O密集型停留在高优先级

#### 6. 公平共享调度(FSS) ===> 公平是第一要素
控制用户对系统资源的访问
1. 某些用户组比其他的用户组更重要        
2. 不重要的组无法垄断资源      
3. 未使用的资源按照比例分配      
4. 没有达到资源使用率的目标的组获得更高的优先级       

------
## 实时操作系统
### 1. 特点
正确性依赖于其时间和功能两方面的操作系统
性能指标：时间约束的及时性；速度和平均性能相对不重要            
特性：时间约束的可预测性      

### 2. 分类
1. 强实时操作系统: 要求在指定的时间内必须完成重要的任务
2. 弱实时操作系统: 重要进程有高优先级，要求尽量但非必须完成


------
## 多处理器调度
### 1. 特征
多个处理机组成一个多处理机系统；处理机间可负载共享      

### 2. 对称多处理器(SMP, Symmetric multiprocessing)调度
1. 每个处理器运行自己的调度程序
2. 调度程序对共享资源的访问需要进行同步

### 3. 进程分配
1. 静态进程分配：进程从开始到结束都被分配到一个固定的处理机上执行，每个处理机有自己的就绪队列，调度开销小，各处理机可能忙闲不均
2. 动态进程分配：进程在执行中可分配到任意空闲处理机执行，所有处理机共享一个公共的就绪队列，调度开销大，各处理机的负载是均衡的










