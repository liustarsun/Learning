# 1. 冒泡排序==>把它理解成交换排序，需要交换元素==>原地排序
**思想：越小的元素会经过交换慢慢浮到顶端**      
```
1. 从0开始两两比较，前面的小就交换位置，直到一轮结束，最小的值在最后的位置
2. 继续从0开始，但是上一轮的最后一个不用比较了
3. 如果这一轮没有交换，说明已经是有序的，直接退出

```

------
# 2. 归并排序==>向量==>是一种分治法的排序==>把两个已经排序的序列合并==>递归法
```
1. 申请空间，使其大小为两个已经排序的序列之和，该空间用来放合并后的序列
2. 设定两个指针，分别指向两个已经排序序列的起始位置
3. 比较两个指针指向的元素，选择较小的放到合并空间中，并把其指针移动到下一个位置
4. 重复步骤3直到某一个指针到达最后
5. 把另一序列剩下的直接合并到队尾
```

------
# 3. 插入排序==> 比较，移动元素需要花时间==>需要O(1)的额外空间==>把取出的临时缓存
```
1. 第1个默认是有序的，从第2个开始，先放在临时的额外空间中，从有序序列的最后一个开始比较，找到它应该呆的位置
2. 移动元素，把它应该呆的位置空出来
3. 把它插入它应该呆的位置
4. 这个应该是没有提前中止的情况
```

------
# 4. 选择排序==> 比较，交换==>可以理解为原地排序
```
1. 从没有排序的队列里面找出最小(大)的，放到起始位置
2. 从剩余的里再找出最小(大)的，接着放到前面
3. 依次循环，应该没有提前中止的情况
```

------
# 5. 归并排序==>列表==>迭代法==>先拆分，再合并==>还算很好理解的样子
```
1. 把序列每两个相邻的作归并，形成ceil(n/2)个序列，排序后每个序列包含1/2个元素
2. 此时如果序列数不是1，继续归并，形成ceil(n/4)个序列，每个序列包含3/4个元素
3. 重复2，直到序列数为1

```

------
# 6. 桶排序
思想：把数组分到有限的桶中，每个桶再分别排序(可能使用其他排序算法，也可能递归使用桶排序)===>**桶排序不是比较排序**      
```
1. 设置一个定量的数组当作空桶
2. 遍历序列，把项目一个一个放到对应的桶中
3. 对每个不是空桶进行排序
4. 从不是空桶里把元素再放回原来的序列中

```

------
# 7. 基数排序
```


```


------
# 8. 快速排序==>划分交换排序==>也是使用分治方法==>重点在于找这个中位数
```
1. 随机从序列中找个元素，作为基准
2. 小于它的放基准的前面，大于它的放基准的右边，等于就无所谓了，则一次排序后，基准就位于中间位置
3. 递归的对前面和后面的子序列排序
```

------
# 9. 希尔排序==>递减增量排序==>是插入排序的改进版本
1. 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率
2. 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位==>因为每次只能选出一个位置
3. 原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。V. Pratt的书[1]对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些
```
希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）

一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）

例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：

13 14 94 33 82
25 59 94 65 23
45 27 73 25 39
10
然后我们对每列进行排序：

10 14 73 25 23
13 27 94 33 39
25 59 94 65 82
45
将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：

10 14 73
25 23 13
27 94 33
39 25 59
94 65 82
45
排序之后变为：

10 14 13
25 23 33
27 25 59
39 65 73
45 94 82
94
最后以1步长进行排序（此时就是简单的插入排序了）。


```

------
# 10. 堆排序
利用堆这种数据结构所设计的一种排序算法，**堆积是一个近似完全二叉树的结构，并满足堆积的性质：即子结点的键值或索引总是小于(或者大于)它的父结点**      


## 10.1 堆结点访问
```
通常堆是用一维数组来实现的，在数组起始位置为0的情况中：
1. 父结点i的左子结点的位置为2i+1
2. 父结点i的右子结点的位置为2i+2
3. 子结点i的父结点的位置为floor((i-1)/2)

```

## 10.2 堆的操作
在堆的数据结构中，堆中最大值总是位于根结点(优先队列使用堆的话，最小值位于根结点)      
```
1. 最大堆调整：将堆的末端子结点作调整，使得子节点永远小于父结点
2. 创建最大堆：将堆所有数据重新排序
3. 堆排序：移除位在第一个数据的根结点，并做最大堆调整的递归运算
```

------
# 11. 计数排序
```


```