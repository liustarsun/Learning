# 1. 图灵机
**图灵机**理论通过假设模型证明了任意复杂的计算都能通过一个个简单的操作完成，从而从理论上证明了**无限复杂计算**的可能性，直接给计算机的诞生提供了理论基础

# 2. 算法
**基于特定的计算模型，目的是解决某个信息处理问题，而设计出来的一个指令序列**，算法应该具备以下特征：        

## 2.1 输入输出
有输入数据和要求的输出的结果    

## 2.2 基本操作，确定性，可行性
所谓的确定性和可行性，是指算法应该描述为**若干语义明确的基本操作序列组成的指令序列**，并且**每个基本操作在对应的模型中均可以兑现**

## 2.3 有穷性和正确性
能正确的算出结果，即算法总会结束，并且给的输出结果应该符合由问题本身在事先确定的条件     

## 2.4 退化性和鲁棒性
尽可能充分的应对各种情况，并且根据实际的情况能够优化或变化

## 2.5 重用性==>通用性
算法的总体框架是否能够推广到其他场合     

------
# 3. 算法效率

## 3.1 可计算性
用某种编程语言，编写符合语法，能够编译/解释，执行的代码是第一步

## 3.2 难解性
问题的最低求解时间成本，应当不超出目前系统所能提供的计算能力

## 3.3 计算效率
时间效率，空间效率，通过研究和归纳算法设计与实现过程中的一般性规律和技巧，编写出效率更高，能够处理更大规模数据的程序    

## 3.4 数据结构
对所给数据，进行存储，组织，转移和变化等操作

------
# 4. 复杂度
## 4.1 时间复杂度
执行时间的变化**可以表示为输入规模的一个函数T(n)**==>特定算法处理规模为n的问题所需要的时间==>**时间复杂度定义为在规模为n的所有输入中，选择执行时间最长者为T(n)==>以此来衡量算法的复杂度**     

## 4.2 渐进复杂度
着眼长远，更为注重时间复杂度的总体变化趋势和增长速度的策略和方法，称为渐进分析    

### T(n)的渐进上界==>大O记号
若存在正的常数c和函数f(n)，使得对于任何n >> 2都有：T(n) <= c * f(n)，则可认为在n足够大以后，f(n)给出T(n)增长速度的一个上界，记为：T(n)=O(f(n))

### 大O的性质：
1. 对于任意常数c，都有O(f(n))= O(c * f(n))===> **常正系数忽略**
2. 对于任意a>b>0，都有O(n=>a次方 + n=>b次方) = O(n=>a次方)===>**只保留最高次项**

### T(n)含义转变
随着机器配置，操作系统不同，时间会有很大的出入，因此另一种自然可行的解决方案是：把时间复杂度理解为**算法中各个指令执行的时间之和，在图灵机和随机存储计算模型中，指令语句可以分解为若干次基本操作，而在多数环境上，这些操作都可以在常数时间内完成**==>**T(n)重新定义为所执行的基本操作的总次数**

### 最坏，最好，平均
1. **大O是最坏情况**，在某些时候，最坏情况下的响应速度才是唯一的指标  
2. **大Ω是最好情况**，定义为：若存在正的常数c和函数g(n)，使得对于任何n >> 2都有：T(n) >= c * g(n)，则可认为在n足够大以后，f(n)给出T(n)增长速度的一个下界，记为：T(n)=Ω(g(n))
3. **大Θ是准确估计**，是对算法的时间复杂度作出**定量的界定**，即从渐进的趋势看，T(n)位于Ω(g(n))和O(f(n))之间；定义为：若存在正的常数c1<c2和函数h(n)，使得对于任何n >> 2都有： c1 * h(n) =<T(n) <= c2 * h(n)，则可认为在n足够大以后，h(n)给出T(n)增长速度的一个确界，记为：T(n)=Θ(h(n))==>**任何时候，T(n)和Θ(h(n))都同阶**

**加一张图**

## 4.3 空间复杂度
算法所需要存储空间的多少也是衡量算法性能的重要方面，即所谓的空间复杂度==>**输入数据本身所占用的空间并不计入空间复杂度**==>**而转存，中专，索引，映射，缓冲等各个方面所消耗的空间，则应该计入**     
通常只关注时间复杂度，来自于以下事实：就渐进复杂度的意义而言，在任一算法的任何一次运行过程中所消耗的存储空间，都不会多于其执行期间基本操作的次数

------
# 5. 复杂度分析
## 5.1 常数O(1)

## 5.2 对数O(logn)

## 5.3 线性O(n)

## 5.4 O(nlogn)

## 5.5 O(n的2次方)

## 5.6 O(n的3次方)

## 5.7 O(2的n次方)==>这中复杂度的算法通常无法应用于实际问题，它们不是有效算法

------
# 6. 递归
分支转向是算法的灵魂，函数和过程及其之间的相互调用，是在经过抽象和封装后，实现分支转向的重要机制==>**递归是函数和过程调用的特殊形式==>它允许函数和过程进行自我调用**

## 6.1 线性递归
终止的条件称为**递归基**==>线性递归一般可以分为两个部分：**一部分对应于单独的某个元素，可以直接求解；另一部分对应于剩余部分，且结构和原问题相同**==>**子问题经过简单的合并之后，可以得到原问题的解**      

**减而治之的算法策略：**==>递归深入一层，待求解问题都缩小常数规模，直到最终得到原问题的解      

### 递归分析方法之==>递归跟踪
按照以下原则，把递归算法的执行过程整理为图的形式：
1. 算法每个递归实例都表示为一个方框，其中注明了该实例调用的参数
2. 若实例M调用实例N，则在M和N之间的方框添加一条有向线

**递归过程中，实例的创建和销毁操作由操作系统负责完成**      

### 递归分析方法之==>递推方程
该方法无法给出具体的调用过程，而是对递归模式的数学归纳，导出复杂度定界函数的递推方程(组)及边界条件，从而将复杂度的分析，转化为递归方程(组)的求解

## 6.2 尾递归

## 6.3 二分递归

------
# 7. 抽象数据类型ADT==>Abstract Data Type
各种数据结构都可以看成若干数据项组成的集合，同时对数据项提供一系列的操作
