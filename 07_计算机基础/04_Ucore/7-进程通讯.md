# 进程通讯

------
## 1. 同步互斥
- 互斥是指**某一资源**同时只允许一个进程对其进行访问，具有**唯一性和排它性**，但互斥**不用限制进程对资源的访问顺序**，即访问可以是无序的
> 访问无序

- 同步是指在进程间的执行**必须严格按照规定的某种先后次序来运行，即访问是有序的，**这种先后次序取决于要系统完成的任务需求
> 访问有序

- 在进程**写资源**情况下，进程间要求满足**互斥条件**。在进程读资源情况下，可允许多个进程同时访问资源

- 同步互斥有多种手段，如**时钟中断管理、等待队列、信号量、管程机制(包含条件变量设计)等，**并基于信号量实现了哲学家问题的执行过程
> 同步互斥是IPC的概念？

### 1.1 同步互斥的底层支撑
- 由于**有处理器调度**的存在，且进程在访问某类资源暂时无法满足的情况下，进程会进入**等待状态**。这导致了**多进程执行时序的不确定性**和**潜在执行结果的不确定性**

- 为了确保执行结果的**正确性**，需要设计更加完善的**进程等待**和**互斥的**底层支撑机制，确保能正确提供**基于信号量和条件变量**的**同步互斥机制**

- 根据操作系统原理的知识，如果没有在硬件级保证**读内存-修改值-写回内存的原子性**，我们只能通过复杂的软件来实现同步互斥操作。但由于有**定时器**、**屏蔽/使能中断**、**等待队列wait\_queue支持test\_and\_set\_bit**等**原子操作机器指令**的存在，使得我们在实现**进程等待**、**同步互斥**上得到了极大的简化

------
## 2. 定时器
- 在传统的操作系统中，定时器是其中一个基础而重要的功能.它**提供了基于时间事件的调度机制**
> 中断的概念？

- 在ucore 中，时钟(timer)中断给操作系统提供了**有一定间隔的时间事件**，操作系统将其作为**基本的调度和计时单位**(我们记两次时间中断之间的**时间间隔为一个时间片**，timer splice)

- 基于此时间单位，操作系统得以**向上提供基于时间点的事件**，并**实现基于时间长度的睡眠等待和唤醒机制**。在每个时钟中断发生时，操作系统产生**对应的时间事件**。应用程序或者操作系统的其他组件可以以此来**构建更复杂和高级的进程管理**和**调度算法**
> sched.h, sched.c 定义了有关timer的各种相关接口来使用timer服务，其中主要包括:typedef struct {……} timer\_t: 定义了 timer\_t 的基本结构，其可以用sched.h中的timer_init函数对其进行初始化    
> void timer\_init(timer t *timer, struct proc\_struct *proc, int expires): 对某定时器进行初始化，让它在expires时间片之后唤醒proc进程     
> void add\_timer(timer t *timer): 向系统添加某个初始化过的timer\_t，该定时器在 指定时间后被激活，并将对应的进程唤醒至runnable(如果当前进程处在等待状态)       
> void del\_timer(timer_t *time): 向系统删除（或者说取消） 某一个定时器。该定时器在取消后不会被系统激活并唤醒进程    
> void run\_timer\_list(void): 更新当前系统时间点，遍历**当前所有处在系统管理内的定时器，找出所有应该激活的计数器，并激活它们**。该过程在且只在每次定时器中断时被调用      

- 在ucore 中，其还会调用调度器事件处理程序
- 一个timer_t在系统中的存活周期可以被描述如下：    
1. timer\_t在某个位置被创建和初始化，并**通过add_timer加入系统管理列表中**      
2. 系统时间被不断累加，直到run\_timer\_list发现该timer\_t到期     
3. run\_timer\_list更改对应的进程状态，并从系统管理列表中移除该timer_t

- 作为系统重要的组件(同时定时器也是调度器的一个部分)，应该了解**其相关机制**和**在ucore中的实现方法和使用方法**。且在**trap_dispatch函数中修改之前对时钟中断的处理**，使得ucore能够利用定时器提供的功能**完成调度和睡眠唤醒**等操作


------
## 3. 屏蔽和使能中断
- 在ucore中提供的底层机制包括**中断屏蔽**/**使能控制**等
> kern/sync.c中实现的开关中断的控制函数local\_intr\_save(x)和local\_intr\_restore(x)，它们是基于kern/driver文件下的intr_enable()、intr\_disable()函数实现的

- 具体调用关系为：
> 关中断：local\_intr\_save --> \_\_intr\_save --> intr\_disable --> cli      
> 开中断：local\_intr\_restore--> \_\_intr\_restore --> intr\_enable --> sti

- 最终的cli和sti是x86的机器指令，最终实现了关(屏蔽)中断和开(使能)中断，即设置了eflags寄存器中与中断相关的位
- 通过关闭中断，可以**防止对当前执行的控制流被其他中断事件处理所打断**。既然不能中断，那也就意味着在内核运行的**当前进程无法被打断或被重新调度**，即实现了**对临界区的互斥操作**。所以在单处理器情况下，可以通过**开关中断实现对临界区的互斥保护**，需要互斥的临界区代码的一般写法为：

```
local_intr_save(intr_flag);
{
临界区代码
} local_intr_restore(intr_flag);
```

- 由于目前ucore只实现了对单处理器的支持，所以通过这种方式，就可简单地支撑互斥操作了。在多处理器情况下，这种方法是无法实现互斥的，因为屏蔽了一个CPU的中断，只能阻止本地CPU上的进程不会被中断或调度，并不意味着其他CPU上执行的进程不能执行临界区的代码
> 所以，**开关中断只对单处理器下的互斥操作起作用**。在本实验中，开关中断机制是**实现信号量**等**高层同步互斥原语**的**底层支撑基础**之一


------
## 4. 等待队列

- 到目前为止，我们的实验中，用户进程或内核线程还没有**睡眠的支持机制**。在课程中提到用户进程或内核线程可以转入等待状态以等待某个特定事件(比如睡眠,等待子进程结束,等待信号量等)，当该事件发生时这些进程**能够被再次唤醒**
- 内核实现这一功能的一个**底层支撑机制就是等待队列wait\_queue**，等待队列和每一个事件(睡眠结束、时钟到达、任务完成、资源可用等)联系起来。需要等待事件的进程在**转入休眠状态后插入到等待队列中**。当事件发生之后，**内核遍历相应等待队列，唤醒休眠的用户进程或内核线程**，并**设置其状态为就绪状态**(PROC\_RUNNABLE)，并将该进程从等待队列中清除
> ucore在kern/sync/{ wait.h,wait.c }中实现了**等待项wait结构和等待队列wait queue结构以及相关函数**，这是实现ucore中的**信号量机制和条件变量机制**的基础，进入wait queue的进程会被设为**等待状态(PROC_SLEEPING)，直到他们被唤醒**       

```
// 数据结构定义
typedef struct {
    struct proc_struct *proc;    //等待进程的指针
    uint32_t wakeup_flags;       //进程被放入等待队列的原因标记
    wait_queue_t *wait_queue;    //指向此wait结构所属于的wait_queue
    list_entry_t wait_link;      //用来组织wait_queue中wait节点的连接
} wait_t;

typedef struct {
    list_entry_t wait_head;      //wait_queue的队头
} wait_queue_t;

le2wait(le, member)              //实现wait_t中成员的指针向wait_t 指针的转化
```

------
## 5. 信号量
- 信号量是一种同步互斥机制的实现，普遍存在于现在的各种操作系统内核里。相对于spinlock的应用对象，**信号量的应用对象是在临界区中运行的时间较长的进程。等待信号量的进程需要睡眠来减少占用CPU的开销**

- 信号量实现的原理性描述：
```
struct semaphore {
    int count;
    queueType queue;
};

void semWait(semaphore s)
{ 
    s.count--;
    if (s.count < 0) {
        /* place this process in s.queue */;
        /* block this process */;
    } 
} 
void semSignal(semaphore s)
{ 
    s.count++;
    if (s.count<= 0) {
        /* remove a process P from s.queue */;
        /* place process P on ready list */;
    } 
}
```

- 基于上诉信号量实现可以认为，当多个(>1)进程可以**进行互斥或同步**合作时，一个进程会由于无法满足信号量设置的某条件而在某一位置停止，直到**它接收到一个特定的信号(表明条件满足了)**。为了发信号，需要使用一个**称作信号量的特殊变量**。为通过信号量s传送信号，信号量的V操作采用进程可执行原语semSignal(s)；为通过信号量s接收信号，信号量的P操作采用进程可执行原语semWait(s)；如果相应的信号仍然没有发送，则进程被阻塞或睡眠，直到发送完为止

- ucore中信号量参照上述原理描述，建立在开关中断机制和wait_queue的基础上进行了具体实现。信号量的数据结构定义如下：

```
typedef struct {
    int value; //信号量的当前值
    wait_queue_t wait_queue; //信号量对应的等待队列
} semaphore_t;
```
- semaphore\_t是最基本的记录型信号量(record semaphore)结构，包含了用于计数的整数值value，和一个进程等待队列wait\_queue，一个等待的进程会挂在此等待队列上

- 在ucore中最重要的信号量操作是**P操作函数down**(semaphore\_t *sem)和**V操作函数up**(semaphore\_t *sem)。但这两个函数的具体实现是\_\_down(semaphore\_t *sem, uint32\_t wait\_state)函数和\_\_up(semaphore\_t *sem, uint32\_t wait\_state)函数，二者的具体实现描述如下：

- \_\_down：具体实现信号量的P操作，首先**关掉中断**，然后判断当前信号量的value是否大于0。如果是>0，则表明**可以获得信号量，故让value减一**，并打开中断返回即可；如果不是>0，则表明无法获得信号量，故需要将当前的进程**加入到等待队列中**，并打开中断，然后运行调度器选择另外一个进程执行。如果被V操作唤醒，则把自身关联的wait从等待队列中删除(此过程需要先关中断，完成后开中断)
- 具体实现如下所示：
```
static __noinline uint32_t __down(semaphore_t *sem, uint32_t wait_state) {
    bool intr_flag;
    local_intr_save(intr_flag);
        if (sem->value > 0) {
        sem->value --;
        local_intr_restore(intr_flag);
        return 0;
    } 
    wait_t __wait, *wait = &__wait;
    
    wait_current_set(&(sem->wait_queue), wait, wait_state);
    
    local_intr_restore(intr_flag);
    schedule();
    local_intr_save(intr_flag);
    
    wait_current_del(&(sem->wait_queue), wait);
    local_intr_restore(intr_flag);
    
    if (wait->wakeup_flags != wait_state) {
        return wait->wakeup_flags;
    } 
    
    return 0;
}
```

------
## 6. 管程和条件变量

- 引入了管程是**为了将对共享资源的所有访问及其所需要的同步操作集中并封装起来**
- Hansan为管程所下的定义：**一个管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据**。有上述定义可知，管程由四部分组成：
1. 管程内部的共享变量       
2. 管程内部的条件变量      
3. 管程内部并发执行的进程      
4. 对局部于管程内部的共享数据设置初始值的语句      

- 局限在管程中的数据结构，只能**被局限在管程的操作过程所访问，任何管程之外的操作过程都不能访问它** 
- 另一方面，**局限在管程中的操作过程也主要访问管程内的数据结构**
- 由此可见，管程相当于一个隔离区，它**把共享变量和对它进行操作的若干个过程围了起来**，所有进程**要访问临界资源**时，都必须**经过管程**才能进入，而管程**每次只允许一个进程进入管程**，从而需要确保**进程之间互斥**

- 但在管程中仅仅有互斥操作是不够用的。进程**可能需要等待某个条件Cond为真**才能继续执行。如果采用忙等(busy waiting)方式：while not(Cond) do {}，在单处理器情况下，**将会导致所有其它进程都无法进入临界区使得该条件Cond为真**，该管程的执行将会发生死锁。为此，可引入条件变量(Condition Variables，简称CV)
> 一个**条件变量CV**可理解为**一个进程的等待队列**，队列中的进程**正等待某个条件Cond变为真**。每个条件变量关联着一个条件，如果条件Cond不为真，则进程需要等待，如果条件Cond为真，则进程可以进一步在管程中执行

- 需要注意当一个进程等待一个条件变量CV(即等待Cond为真)，该进程需要退出管程，这样才能让其它进程可以进入该管程执行，并进行相关操作，比如设置条件Cond为真，改变条件变量的状态，并唤醒等待在此条件变量CV上的进程。因此对条件变量CV有两种主要操作：
1. wait_cv： 被一个进程调用，以等待断言Pc被满足后该进程可恢复执行. 进程挂在该条件变量上等待时，不被认为是占用了管程       
2. signal_cv：被一个进程调用，以指出断言Pc现在为真，从而可以唤醒等待断言Pc被满足的进程继续执行       

------
## 7. 实验要求
- 本次实验要求用管程机制**实现哲学家问题**的执行过程。在实现信号量机制和管程机制时，需要**让无法进入临界区的进程睡眠**，为此在ucore中设计了等待队列wait_queue。**当进程无法进入临界区(即无法获得信号量)时**，可**让进程进入等待队列**，这时的进程**处于等待状态(也可称为阻塞状态)**，从而会让实验六中的**调度器选择一个处于就绪状态**(即RUNNABLE STATE)的进程，进行进程切换，让新进程有机会占用CPU执行，从而让整个系统的运行更加高效。

- 在实验七中的ucore初始化过程，开始的执行流程都与实验六相同，直到执行到创建第二个内核线程init\_main时，修改了init\_main的具体执行内容，即增加了check\_sync函数的调用，而位于lab7\_figs/kern/sync/check_sync.c中的check\_sync函数可以理解为是**实验七的起始执行点，是实验七的总控函数**。进一步分析此函数，可以看到这个函数主要分为了两个部分:
1. 第一部分是实现基于信号量的哲学家问题        
2. 第二部分是实现基于管程的哲学家问题          

- 对于check_sync函数的第一部分，首先**实现初始化了一个互斥信号量**，然后**创建了对应5个哲学家行为的5个信号量**，并创建5个内核线程代表5个哲学家，每个**内核线程完成了基于信号量的哲学家吃饭睡觉思考行为实现**
- 对于check_sync函数的第二部分，首先**初始化了管程**，然后**又创建了5个内核线程代表5个哲学家**，每个内核线程要**完成基于管程的哲学家吃饭、睡觉、思考的行为实现**。这部分需要学生来具体完成。学生需要掌握如何用信号量来实现条件变量，以及包含条件变量的管程如何能够确保哲学家能够正常思考和吃饭