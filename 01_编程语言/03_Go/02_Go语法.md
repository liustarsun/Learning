# go语法
- 名字开头字母的**大小写**决定了名字在**package外的可见性，大写可见，小写不可见**
------
## 1. 声明
- 四种声明语句：
1. var：变量       
2. const：常量     
3. type：类型    
4. func：函数    

------
## 2. 变量
### 2.1 变量定义格式
```
var 变量名 [变量类型] [= 表达式]
```
- 如果省略**[变量类型]**，则**根据表达式进行推导类型**
- 如果省略**[= 表达式]**，则**使用零值初始化机制**
> 数值对应0，bool对应false，字符串对应空字符串, 接口或引用类型对应的是nil，每个聚合类型是其中的元素对应的0值

- 零值初始化机制**可以确保每个值都有一个良好的初始值，因此GO语言中不存在没初始化的变量**

### 2.2 赋值
```
// 多赋值表达式
var astring, bint, cbool = "hello", 34, false  // string, int, bool
// 可以通过函数，返回多个值进行初始化
var f, err = os.open(name)  // 函数返回file和err两个返回值
```

### 2.3 简短变量声明

- 在**函数内部**，以**“名字:=表达式”**形式**声明和初始化局部变量**，变量的类型则根据表达式自动推导

- 简短变量声明操作(:=)和赋值操作(=)
> **:=**要求至少有一个变量是未声明的，如果已经声明过，则简单变量声明只有简单的赋值操作

------
## 3. 指针
- 指针类型的0值为nil
- Go语言中可以**返回函数中局部变量的地址是允许的**
- 指针使得可以不用名字去访问一个变量
> 这个怎么理解呢？

### 3.1 new函数
- 另一个创建变量的方式是使用new(T)函数，返回的是T类型变量的地址
> C++中new和malloc也是的，都是申请内存的起始地址


### 3.2 变量的生命周期
- 函数的参数变量和返回值变量都是局部变量，在函数每次别调用的时候创建
> 传递的都是副本，不管是指针的副本还是变量的副本，最好是用引用，如果有的话

```
// 这个语法很奇特
func testfunction int {
    hello(a, b, c, d,
        )  // 函数右边的小括号可以另起一行，为了防止编译器自动在行尾插入分号而导致编译错误，可以在最后一个参数后添加逗号
}
```

- Go语言**自动垃圾回收器**，基本实现思路：从每个package级别的变量和每个当前运行函数的每个局部变量开始，通过**指针或引用的访问路径遍历，看能否找到该变量，如果不存在这样的访问路径，则说明该变量是不可达的，也就是说它是否存在并不影响后续的计算结果**
> 因为一个变量的有效期只取决于是否可达，因此循环迭代内部的局部变量的生命周期可能超出其局部作用域；同时局部变量可能在函数返回之后依然存在？

**编译器会自动选择在栈上还是在堆上分配局部变量的存储空间，而不是由var或new声明变量的方式决定**，这个好神奇

### 3.3 元组赋值
- 元组赋值(和python元组不同):允许同时更新多个变量的值，在赋值之前，赋值语句右边的所有表达式将会先进行求值，然后再**统一更新左边变量的值**；和变量声明一样，使用**下划线空白标识符_来丢弃不需要的值**

```
_, ok = x.(T)    // 只检测类型，忽略具体值
```

### 3.4 可赋值性
- 赋值语句是**显式赋值**，还有很多地方会**发生隐式赋值的行为**
- 函数调用会**隐式地将调用参数的值赋值给函数的参数变量**，一个返回语句将**隐式地将返回操作的值赋值给结果变量**，一个**复合类型的字面量也会产生赋值行为**
```
medals := []string{“gold”, "silver", "bronze"}
```
> 不管是隐式还是显式地赋值，在**赋值语句左边的变量**和**右边最终的求到的值**必须**有相同的数据类型**

------
## 4. 类型
- 类型声明语句创建新的类型名称，和现有类型具有相同的底层结构，新命名的类型**提供方法**，用来**分隔不同概念的类型**，这样即使它们底层类型相同也是不兼容的

```
type 类型名字 底层类型

```
- 类型声明语句一般出现在包一级，因此**如果新创建的类型名字的首字符大写，则在外部包也可以使用**
- 对于每个类型T，都有一个对应的**类型转换操作(T(x))**，用于把x转换为T类型(如果T是指针，则为(T)(x));并且**只有当两个类型的底层基础类型相同时，才允许这种转换，这些转换只是改变了类型而不会影响值本身**
- 一个命令的类型可以提供书写方便，尤其是对复杂类型而言
- 命名类型可以为该类型的变量**定义新的行为**，这些行为可以**表示为一组关联到该类型的函数集合，称为类型的方法集**

------
## 5. 包和文件
- Go语言中的包，类似于**其他语言的库或模块的概念**，目的是**为了支持模块化，封装，单独编译和代码复用**；通常一个**包所在目录路径的后缀就是包的导入路径**
- 每个包对应一个独立的名字空间，它**通过控制哪些名字是外部可见来隐藏内部实现信息**
> 在Go语言中，一个简单的规则是，如果一个名字是**大写字母开头的**，则该名字是**可导出的**(因汉字不区分大小写，因此汉字开头的名字是没有导出的)
- 包名在**包的声明处指定，按照惯例，一个包的名字和包的导入路径的最后一个字段相同**
**注意：**        
如果导入一个包，但是又没有使用该包，将被当做一个编译错误处理，这种强制规则可以有效减少不必要的依赖

### 5.1 包的初始化
- 包的初始化**首先是解决包级变量的依赖顺序，然后才按照包级变量声明出现的顺序依次初始化**
- 如果包中含有多个.go源文件，将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译
> 这条规则有何用处？

- 对于在包级声明的变量，如果有初始化表达式则用其初始化，如果没有，则可以使用一个**特殊的init初始化函数来简化初始化工作**
- 每个文件都可以包含**多个init初始化函数**，这个函数**除了不能被调用和引用外**，其他和普通函数类似，每个文件中的init初始化函数，在程序开始执行时**按照它们声明的顺序被自动调用**

------
## 6. 作用域
- 声明语句的作用域是指源代码中可以有效使用这个名字的范围
- 不要把**作用域和生命周期混为一谈**
1. 声明语句的作用域对应的是**一个源代码的文本区域，它是一个编译时的属性**
2. 一个变量的生命周期是指**程序运行时变量存在的有效时间段**，在此时间区域内它可以被程序的其他部分引用，**是一个运行时的概念**

```
1 package main
2
3 import "fmt"
4
5 func main() {
6     fmt.Printf("hello go!\n")
7     var result int = adda(14, 40)
8     fmt.Printf("The result is %d\n", result)
9     fmt.Printf("The tempa value is %d\n", tempa)  // 在此作用域中不可访问
10 }
11
12 func adda(a, b int) int {
13     var tempa int = a
14     tempb := b
15     return tempa+tempb
16 }
~     
```
