# 0. 使用VS查看代码
打开VS2013==> 菜单 ==> 新建 ==> 从现有代码创建项目==>直接导入项目

# 1. 引用类型
定义格式：数据类型& 变量名称 = 被引用的变量名称      
[优秀的C++开源项目](https://www.zhihu.com/question/28341521)
1. 两者类型要相同    
2. 引用类型变量不占用单独的存储空间，和被引用的变量共享存储空间(**不严谨**)===>实际是个指针   
3. 引用必须在定义时初始化(**编译器规则**)     

```
// 源代码
int main()
{
        int a = 10;
        int &b = a;
        b = 100;
        return 0;
}


// 汇编代码
131 00000000004006cd <main>:
132   4006cd:   55                      push   %rbp
133   4006ce:   48 89 e5                mov    %rsp,%rbp
134   4006d1:   c7 45 f4 0a 00 00 00    movl   $0xa,-0xc(%rbp)
135   4006d8:   48 8d 45 f4             lea    -0xc(%rbp),%rax    ;实际上引用还是占用内存的，一个指针的大小，里面保存的是指向被引用类型的地址                                                                                         
136   4006dc:   48 89 45 f8             mov    %rax,-0x8(%rbp)
137   4006e0:   48 8b 45 f8             mov    -0x8(%rbp),%rax
138   4006e4:   c7 00 64 00 00 00       movl   $0x64,(%rax)       ;%rax中保存的实际就是(%rbp-0xc)
139   4006ea:   b8 00 00 00 00          mov    $0x0,%eax
140   4006ef:   5d                      pop    %rbp
141   4006f0:   c3                      retq
```

引用最大的作用是**作为函数的参数**，实际应该也是一个指针       
**常量引用**：引用的对象是个常量，不能通过引用改变目标对象的值       
### 问题：
引用作为返回值时，不产生副本，什么意思？好好研究一下      
===> 实际是返回一个指针， 指向栈上内容的引用不可以返回                
```
// 源代码
#include <iostream>

using namespace std;

int & Inc(int &dest, const int &alpha)
{
        dest += alpha;
        return dest;
}
int main()
{
        int a = 10;
        int b = 100 ;
        int c = Inc(a, b);

        return 0;
}

// 汇编代码
131 00000000004006cd <_Z3IncRiRKi>:
132   4006cd:   55                      push   %rbp
133   4006ce:   48 89 e5                mov    %rsp,%rbp

134   4006d1:   48 89 7d f8             mov    %rdi,-0x8(%rbp)
135   4006d5:   48 89 75 f0             mov    %rsi,-0x10(%rbp)


136   4006d9:   48 8b 45 f8             mov    -0x8(%rbp),%rax
137   4006dd:   8b 10                   mov    (%rax),%edx

138   4006df:   48 8b 45 f0             mov    -0x10(%rbp),%rax
139   4006e3:   8b 00                   mov    (%rax),%eax

140   4006e5:   01 c2                   add    %eax,%edx

141   4006e7:   48 8b 45 f8             mov    -0x8(%rbp),%rax
142   4006eb:   89 10                   mov    %edx,(%rax)

143   4006ed:   48 8b 45 f8             mov    -0x8(%rbp),%rax  // 返回值存放在%rax中

144   4006f1:   5d                      pop    %rbp
145   4006f2:   c3                      retq
146 



147 00000000004006f3 <main>:                                                                                                                     
148   4006f3:   55                      push   %rbp
149   4006f4:   48 89 e5                mov    %rsp,%rbp

150   4006f7:   48 83 ec 10             sub    $0x10,%rsp

151   4006fb:   c7 45 f4 0a 00 00 00    movl   $0xa,-0xc(%rbp)
152   400702:   c7 45 f8 64 00 00 00    movl   $0x64,-0x8(%rbp)

153   400709:   48 8d 55 f8             lea    -0x8(%rbp),%rdx
154   40070d:   48 8d 45 f4             lea    -0xc(%rbp),%rax
155   400711:   48 89 d6                mov    %rdx,%rsi   // 参数放到%rsi中
156   400714:   48 89 c7                mov    %rax,%rdi   // 参数放到%rdi中


157   400717:   e8 b1 ff ff ff          callq  4006cd <_Z3IncRiRKi>
158   40071c:   8b 00                   mov    (%rax),%eax


159   40071e:   89 45 fc                mov    %eax,-0x4(%rbp)
160   400721:   b8 00 00 00 00          mov    $0x0,%eax
161   400726:   c9                      leaveq
162   400727:   c3                      retq

```

# 2. 结构体
## 2.1 和数组区别：    
数组是相同数据类型的集合，结构体是不同类型数据对象构成的集合，当然也可以是相同数据类型      

## 2.2 结构体存储表示
结构体的各个成员的存储空间是连续的，但是**可能并不是紧挨着存放，这是由于硬件架构导致的**，数组一般是**紧挨着的**，通常在结构体中，不同数据类型的成员会按照**4个字节**对齐后存放，使用sizeof获得结构体类型占用空间大小(以字节为单位)            
```
sizeof(结构体); sizeof 结构体;
DATE new_date; // 定义一个结构体
new_date = date; // 和数组不同，结构体是可以直接赋值的，copy过程是逐一成员拷贝，但是会存在浅拷贝问题  ===> 结构体直接赋值
```

## 2.3 结构体数据对象访问
使用点(.)操作符，即成员访问操作符，来访问解析结构体的某个特定成员
```
DATE date; date.year = 2008; date.month = 8; date.day = 10;

```

## 2.4 结构体可以作为函数的返回值
当被调用的子函数返回值为结构体的时候，**调用函数**将分配一段空间用于存放返回的结构体(使用一个结构体变量接受返回值)，并**将这段空间的地址作为调用时的参数压栈**。子程序不负责对要返回的结构体分配空间。最后返回eax中存放的是结构体空间(**栈中**)的地址。在子程序退出的时候，调用函数可以在自己的栈帧中访问到返回的值

### 具体实例
```

```

## 2.5 结构体指针作为返回值
子程序填充malloc在堆中生成的结构体空间，并将其地址存放在eax中返回。但是这种使用方式存在的很大问题是在子程序中使用到了malloc但是没有与之对应的free,如果在调用函数中忽视释放操作的话将会导致堆内存的泄露。当然在C++中可以使用构造函数和析构函数处理这些细节      

-----
# 3. new关键字
1. 命名对象的生命周期由其作用域决定，**但是某些情况下希望把对象和作用域独立开来，即在函数内部创建对象以后，希望在函数返回后，仍然可以使用这些对象**， 运算符new负责创建这些对象，运算符delete则负责删除它们，new分配的对象位于堆上
2. 使用{}列表的形式传递实参，或者使用传统的()形式指定初始化器
> **如果某一类型有默认的构造函数，则可以省略初始化器()，但对内置类型省略的话，则处在未初始化的状态，但是推荐使用{}这种格式**

3. new的对象需要使用delete运算符删除，**如果被删除的对象类型有析构函数，则delete会调用析构函数**      
4. **new[]用来创建对象的数组**，delete用来删除单个对象，**delete[]负责删除数组**
5. 切记不要用new创建局部对象==>**这个和第一条有点违背啊**
6. 当运算符new需要为对象分配空间时，它调用operator new()分配适量的字节；当需要为数组分配空间时，调用operator new[]();**它们的标准是不负责初始化得到的内存**


------
# 4. sprintf函数
和printf函数一样，只是把结果输出到指定字符串中，看起来像是拼接      