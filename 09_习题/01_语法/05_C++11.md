## 4.4 C++ 11新特性
1. auto让编译器通过初始值来推算变量的类型，所以，其定义的变量必须要有初始值   
```
auto a = 10;  // 自动推导类型，常用在泛型编程中
```

2. {}的初始化器，初始化方式，不会导致信息丢失，也就是类型强制性转换
```
int  a{10};
int a{20.7}; // 会引起错误，因为{}不会进行强制类型转换
```
3. const承诺不改变值，主要用于接口说明，**编译器负责确认并执行const的承诺**
4. constexpr: 在**编译时求值，用于说明常量**，作用是**允许把数据放在只读内存中以及提升性能**
```
const int dmv = 17；
constexpr int _temp = 20; // 编译期求值，放在只读内存中

```

5. for循环的新的语法：
```
void print
{
        int v[] = {1, 3, 5, 7, 8, 9};

        for(auto x:v)
        {
                cout <<  x << endl;
        }

}
```

6. 空指针关键字nullptr， 不指向任何对象的关键字

7. 右值引用
左值引用：引用那些希望改变值的对象      
const引用：引用那些不希望改变值的对象      
右值引用：**所引用的对象的值在使用后无需保留了**(临时变量)      
引用的实现方式类似于常量指针，每次使用引用的时候实际上是对该指针进行解引用操作，但是**引用不是对象，指针是对象**          
编译器清楚的知道**函数返回的局部变量的值不会再被用到**，右值引用绑定到右值，**但不能绑定到左值**           
&&表示右值引用，不使用const右值引用，因为右值引用总是假设能够修改所引用的对象           
**只能放在右边的是右值**；**既能**放右边**又能**放左边的是左值            

8. lambda表达式---定义和使用**匿名函数对象的一种简便的方式**
- 传统的方式是：定义一个类，生成类对象，通过对象调用函数
- 把操作当做**实参**传给函数，这个操作称为**回调**

主要包含以下组件：
1. 一个可能为空的**捕获列表**，主要是**定义环境中的那些变量可以在lambda函数体中使用，是以copy的方式使用，还是以引用的方式使用**，捕获列表位于[]中
2. 可选的传入的参数的列表    ------> lambda表达式所需要的参数，参数列表位于()内
3. 一个可选的mutable修饰符
4. 一个可选的noexcept
5. 一个返回的值的类型(->形式的声明)
6. 函数体{}
```
void print_module(const vector<int> &v, ostream & os, int m)
{
        for_each(begin(v), end(v), [&os, m](int x){ if(x%m == 0) os << x << "\n";});
}

&os 表示引用的方式，m表示copy的方式，参数为x
```

9. 委托构造函数：自己调用自己的构造函数
```
    MyClass() : MyClass(10) {}
    MyClass(int d) : data(d){}
```

10. 类内成员初始化器
当提供一个类内初始值时，必须以符号＝或者花括号表示


11. 使用=default生成默认构造函数, 使用delete禁止构造函数
```
public:
    MyClass()=default; // 同时提供默认版本和带参数版本
    MyClass(int i):data(i){}
    MyClass(const MyClass& )=delete;  // 禁止copy
```

12. 继承构造函数
使用using

13. 覆盖控制：override和final
- 和基类的virtual必须一模一样，或者后面加override 告诉继承类必须覆盖，而不是隐藏        
- 隐藏是没有virtual关键字时候和父类的一模一样         
- 隐藏式没有virtual并且函数名和父类一摸一样，参数可以不相同          

14. 容器的移动语义
move操作


16. 资源管理指针
三种智能指针


18. 几种类型转换
const_cast
```
去除复合类型中const和volatile属性

```

static_cast：1. 基础数据类型转换；2. 同一继承体系中的类型转换；3. 任意类型和空指针类型void*之间的转换；4. 在编译期进行检测
```
该运算符把expression转换为type-id类型，在编译时使用类型信息执行转换，在转换执行必要的检测（指针越界，类型检查），其操作数相对是安全的。

但没有运行时类型检查来保证转换的安全性

```

reinterpret_cast：
```
仅仅是复制n1的比特位到d_r, 没有进行必要的分析.interpret_cast是为了映射到一个完全不同类型\
的意思，这个关键词在我们需要把类型映射回原有类型时用到它。我们映射到的类型仅仅是为了故弄\
玄虚和其他目的，这是所有映射中最危险的

```
dynamic_cast
```
1.dynamic_cast是在运行时检查的，用于在集成体系中进行安全的向下转换downcast(当然也可以向上转换，但没必要，因为可以用虚函数实现)

   即：基类指针/引用 -> 派生类指针/引用

   如果源和目标没有继承/被继承关系，编译器会报错！
2.dynamic_cast是4个转换中唯一的RTTI操作符，提供运行时类型检查。
3.dynamic_cast不是强制转换，而是带有某种”咨询“性质的，如果不能转换，返回NULL。这是强制转换做不到的。

4.源类中必须要有虚函数，保证多态，才能使用dynamic_cast<source>(expression)

```
```
asb@docker:C$ g++ ch07.cc -o ch07.out  -std=c++11
asb@docker:C$ g++ ch07.cc -o ch07.out  -std=c++11 -m32

```
### 6. 智能指针
- 代表知道对象的所有权属于谁，谁应该删除对象
- auto_ptr:重载了赋值操作符=，使用delete操作删除指针，然后置位nullptr，或者直接使用reset成员函数
```
// 第一种方式，其中release()：清空当前智能指针对象，并返回类型指针
Base *_tempBase = base1.release;
delete _tempBase;
_tempBase = nullptr;

// 第二种方式，直接删除reset
base.reset // 重置智能指针，即把内存删除，且指向空，但是类型不变

// 重载赋值操作符号，即进行了移交内存的操作，这种情况下，控制权可以随便转换，但是只有一个在用，从而用起来有诸多的限制
```

- unique\_ptr：独占指针对象，禁用的赋值操作和copy构造函数，因此不能任意的转换控制权，想转移控制权，只能使用**move函数**

- shared\_ptr：大家共享所有权，并且有引用计数，当引用计数为0时，delete掉指针，由析构函数来执行对象的操作

- weak\_ptr: 指向shared\_ptr的对象


### 6.1 强制类型转换
1. static_cast

2. dynamic_cast

3. reinterpret_cast

4. const_cast

