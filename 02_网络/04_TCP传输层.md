# 1. TCP传输的特点
1. 提供一种面向连接的，可靠的字节流服务

# 2. 提供可靠服务的方式
1. 应用数据被分割成TCP认为最适合发送的数据块
2. TCP发送一个段后，会启动一个定时器，等待目的端接收到这个报文，如果不能及时收到一个确认，将重发报文
3. 收到消息以后，会发送一个确认，但是确认不是立即发，而是延迟一段时间后发
4. TCP将保持它头部和数据的校验和，这是一个端到端的校验和，目的是检测数据在传输过程中的任何变化，如果收到段的校验和有错，则TCP将丢弃报文段或者不确认报文(等待超时重发)
5. 因为IP有可能失序，所以如果有必要TCP将会对收到的数据进行重新排序
6. 如果IP数据报发生重复，TCP的接收端必须丢弃重复的数据
7. TCP还能提供流控制，TCP连接的一方有固定大小的缓冲空间，TCP接收端只允许另一端发送不超过缓存区大小的数据

**linux的内核对一个应用读或写的内容不做任何解释，而是交给应用程序处理，对内核来说，它无法区分一个二进制文件和一个文本文件**      

# 3. TCP的头部
1. 每个TCP段都包含源端和目的地端口号，**用于寻找发端和收端的应用进程**==>**这两个值加上IP首部中的源端IP地址和目的地段IP地址唯一确定一个TCP的连接**==>**一个IP+端口号有时候也称为一个socket**
> 客户端IP地址+客户端端口号+服务器端IP地址+服务器端端口号==>可以唯一确定TCP连接的双方

2. 提供全双工的服务，即两个方向上能够独立的进行传输==>每一端必须保持每个方向上的传输数据序号
3. TCP的流量控制由连接的每一端通过声明的窗口大小来提供，窗口大小为字节数
4. TCP提供一种可靠的面向字节流传输层服务，它把用户数据打包构成报文段，发送数据后启动一个定时器，另一端对接收的数据进行确认，对失序的数据重新排列，丢弃重复数据；TCP提供端到端的流量控制，并计算和验证一个强制性的端到端的检验和==>telnet，ftp，smtp都使用TCP来传输

# 4. TCP建立连接和终止
```


```

# 5. TCP交换数据



# 6. TCP滑动窗口
## 6.1 停止等待协议
数据发送方在发送下一条数据前，要停下来，等到接收到**对方**对发送数据的确认    

## 6.2 滑动窗口控制协议
允许发送方在收到确认消息前，发送多组数据，因为不用每发一组就停下来**等待对方发过来的确认数据**，所以能加速数据的传输==>**接收方不需要确认每一个收到的分组**    
在TCP中，ACK是累积的===>表示接收方已经收到了**一直到确认序号减1的所有的字节**

### 四种报文==>发送方
1. 发送并被确认的
2. *发送未被确认的*
3. *能够发送的ASAP*
4. 不能发送，直到窗口移动

**斜体部分为提供的窗口===>接收方通告的===>总的窗口**          
**可用窗口==>总的窗口-发送未被确认的==>当接收方确认数据后，滑动窗口会不断右移**

### 窗口左右边缘的移动
1. 窗口左边缘向右移动==>窗口合拢==>发生在数据被发送和确认时
2. 窗口右边缘向右移动==>窗口张开==>允许发送更多的数据==>对端接收进程读取已经确认的数据并释放了TCP的接收缓存时
3. 窗口右边缘向左移动==>窗口收缩==>**不建议这种**

**如果左边缘到达右边缘，则称为一个零窗口，此时发送方不能发送任何数据**==>每当回ACK的时候，会告诉发送端接收端目前的窗口大小==>更新发送端窗口==>**并且会影响到右边缘是否向右移动**


## 6.3 窗口大小
由接收方的接收进程控制==>会影响TCP的性能   

## 6.4 PUSH标志
发送方使用这个标志==>通知接收方==>要求接收方把所有收到的数据(包括和PUSH一起传送的数据+接收方TCP已经为接收进程收到的其他的数据)==>提交给接收进程   
目的：**客户端进程通知TCP在向服务器发送一个报文段时，不要因为等待额外数据而使已经提交的数据在缓存中滞留**===>**发送端**
**服务器端收到一个设置了PUSH标志的报文时，需要立即把数据递交给服务器进程而不能等待判断是否还有额外的数据到达**===>**接收端**      
以上的PUSH标志已经过时，一个好的TCP应该能够自行决定何时设置这个标志==>一些其他的应用方式==>写入缓存后，立即被发送

## 6.5 慢启动
发送方一开始**向网络发送接收端能够处理的窗口大小**，但是如果遇到发送方和接收方中间有多个**慢速路由时**，就可能会出现问题，**一些中间路由必须缓存分组，并有可能耗尽存储器的空间**，这种方式也会严重降低TCP连接的吞吐量      
慢启动算法通过观察到**新分组进入网络的速率**应该与**另一端返回确认的速率相同**而工作        

### 拥塞窗口
慢启动给**发送方的TCP增加另一个窗口**==>**拥塞窗口(cwnd)**
1. 当和另一个网络的主机建立TCP连接时，拥塞窗口被初始化为**1个报文段(另一端通告的报文段大小==>确定时1？？？)**
2. 每当收到1个ACK，拥塞窗口就增加一个报文段**(cwnd以字节为单位，但是慢启动以报文段大小为单位进行增加)**
3. 发送方取**拥塞窗口和通告窗口的最小值作为发送上限**
4. **拥塞窗口是发送方的流量控制，通告窗口时接收方的流量控制**

### 例子
1. 发送方发送一个报文段，然后等待ACK，当收到ACK以后，拥塞窗口从1增加到2==>可以发送两个报文段==>收到2个ACK以后，拥塞窗口增加到4==>指数增加的关系
2. 当某些点达到互联网容量，于是中间路由器开始丢弃分组==>通知发送方，拥塞窗口太大
   

# 7. TCP超时重传
通过在发送时设置**定时器**来解决数据和ACK丢失的问题==>**定时器超时，没有收到ACK，就重新传数据**==>核心问题：**怎样决定超时间隔, 如何确定重传的频率**

## 7.1 四个定时器
### 重传定时器==>希望收到另一端的ACK
### 坚持定时器==>使滑动窗口信息保持不断流动，即使另一端关闭了接收窗口
### 保活定时器==>检测一个空闲连接的另一端何时崩溃或者重启
### 2MSL定时器==>测量一个处于TIME_WAIT状态的时间

## 7.2 往返时间测量
TCP超时和重传中最重要的部分是**给定连接的往返时间(RTT)的测量**==>由于路由器和网络流量都会变化，因此这个时间也会变化===>TCP应该跟踪这些变化，**并且相应的改变其超时时间**
1. TCP需要测量在发送一个带有特别序号的字节和接收到包含该字节的确认之间的RTT

## 7.3 拥塞避免算法
由于发送数据达到中间路由器的极限，此时分组被丢弃，而拥塞算法就是一种处理丢失分组的方法       
分组假定由于受到损坏而引起的丢失非常少，因此分组丢失就意味着**源主机和目标主机之间在某处发生了拥塞**==>两种分组丢失的指示：**发生超时和接收到重复的ACK**
> 拥塞避免算法和慢启动算法是两个目的不同，独立的算法；但是**当发送拥塞时，通常希望降低分组进入网络的传输速率，因此可以调用慢启动来做这一点**==>实际应用中，这两个算法通常在一起实现

### 算法实现
拥塞避免算法和慢启动算法**需要对每个连接维持两个变量**===>**拥塞窗口cwnd和慢启动门限ssthresh**        
1. 对于一个连接，初始化cwnd为1个字节，ssthresh为65535个字节
2. TCP的发送进程的发送**不能超过cwnd和接收通告窗口的大小**==>**拥塞避免是发送方使用的流量控制(发送方感受到的网络拥塞估计)**==>**接收窗口是接收方使用的流量控制(接收方在该连接上的可用缓存大小)**
3. 当拥塞发生时(超时或收到重复ACK)==>ssthresh被设置为当前窗口大小的一半(**当前窗口时cwnd和接收通告窗口的小的那个，但是最少要2个报文段**)==>如果超时引起了拥塞, cwnd就被设置为1个报文段==>**慢启动**
4. 新的数据被对端确认时，就增加cwnd==>**增加的方法依赖于是否正在进行慢启动或拥塞避免**==>如果cwnd小于或等于ssthresh==>正在慢启动===>否则时拥塞避免==>慢启动一直持续到回到当拥塞发生时所处位置的半时候才停止(**因为记录了在步骤2中给我们制造麻烦的窗口大小的一半**)==>然后转为拥塞避免

## 7.4 快速重传和快速恢复算法
1. 当收到第3个重复的ACK的时候，将ssthresh设置为当前拥塞窗口的cwnd的一半，重传丢失的报文段===>设置cwnd为ssthresh加上3倍的报文段大小
2. 每次收到另一个重复的ACK时，cwnd增加1个报文段大小并发送1个分组==>如果新的cwnd允许发送
3. 当下一个确认新数据的ACK到达时，设置cwnd为ssthresh(在第1步中设置的值)==>这个ACK应该是在进行重传后的一个往返时间内对步骤1中重传的确认==>采用的是拥塞避免(因为当分组丢失时将当前的速率减半)

------
# 8. TCP的坚持定时器
接收和发送双方因为等待彼此而出现死锁的情况：接收方等待接收数据(因为它已经向发送方通告了一个非0的窗口)==>发送方则等待允许它继续发送数据的窗口更新
**解决方案**：  
发送方使用一个坚持定时器来周期性地向接收方进行查询，以便发现窗口是否已增大==>**这些从发送方发出的报文段称为窗口探查**      
连接的一方需要发送数据，但是对方已经通告窗口的大小为0，此时就需要设置坚持定时器，不断地探测已经关闭的窗口==>这个探测过程会一直持续下去     



------
# 9. TCP的保活定时器
保活功能主要时为**服务器端的应用程序提供的**==>服务器应用程序需要知道客户主机是否崩溃


## 9.1 T/TCP==>为事物用的TCP扩展
TCP提供的是一种虚电路的方式的运输服务，一个连接的生存时间包括**建立连接，数据传输，连接终止三个阶段**==>虚电路服务适合如**远程注册，文件传输之类的应用**      
还有其他的应用程序被设置为**使用事务服务**==>一个事务(transaction)就是符合**以下特征的一个客户请求及随后的服务器响应**===>**事务=客户请求+随后的服务器响应**        

**客户请求符合以下的特征**：       
1. 应该避免连接建立和连接终止的开销===>**在可能的时候，发送一个请求分组并接收一个应答分组**
2. 等待时间应该**减少到等于RTT和SPT之和**==>**RTT(Round-Trip Time)为往返时间** + **SPT(Server Processing Time)为服务器处理请求的时间**
3. 服务器应该能够检测到重复请求，并且当收到重复请求时不重新处理事务(**意味着不必再次处理请求，而是返回保存的，和该请求对应的应答**)

**域名服务器就是事务类型**


## 9.2 T/TCP的定义
1. 通常的应用程序设计人员，面对的是使用TCP还是UDP作为传输层的协议；TCP提供了过多的事务控制，而UDP提供的又不够(动态超时重传，拥塞避免等都没有)，因此才有了T/TCP的产生    
2. 大多数的TCP需要使用**7个报文来打开或者关闭一个连接**===>三次握手，四次关闭      
3. 现在增加3个报文段==>**一个对应于请求 + 一个对应于应答和对请求的确认ACK + 一个对应于应答的确认**

### T/TCP使用加速来打开来避免三次握手
1. 它为打开的连接指定一个32bit的连接计数CC(Connection Count)==>无论主动打开还是被动打开，主机的CC值从全局计数器中获得==>该计数器每次被使用时，**加1**
2. 在两个使用T/TCP的主机之间的每个报文段都包含一个新的TCP选项CC==>长度为6个字节，包含发送方在该连接上的32bit的CC值
3. 一个主机维护一个缓存，该缓存**保留每个主机上一次的CC值**==>**值从来自这个主机的一个可接受的SYN报文段中获得**
4. 开始的SYN收到报文段时，检测收到的CC值和本地缓存的CC值，如果接收到的CC值大==>**SYN是新的，报文段中的任何数据被传递给接收应用进程**==>这个连接称为半同步；如果接收的CC值小或者接收端没有对应这个客户的缓存CC==>**执行三次握手**
5. 为了响应一个开始的SYN，带有SYN和ACK的报文段在另一个被称为**CCECHO的选项中回显所接收到的CC值**
6. 在要给非SYN报文段中的CC值检测和拒绝来自同一连接的前一个替身的任何重复的报文段

------