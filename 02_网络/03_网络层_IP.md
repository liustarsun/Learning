# 1. IP==>网络层==>网际协议
提供不可靠，无连接的数据报传送服务    
## 1.1 不可靠
不保证IP数据报能成功到达目的地，IP只提供最好的传输服务；一种简单的错误处理算法：丢弃该数据报，然后发送ICMP消息给信源端，任何要求的可靠性都必须要上层来提供(如TCP)      

## 1.2 无连接
IP并不维护任何关于后续数据报的状态信息，每个数据报的处理都是独立的，这就代表数据报可以不按照发送顺序接收

# 2. IP头部
1. 不包含选项字段的IP数据报有20字节的头部    
2. 网络字节序列是按照0-7，8-15，16-23，24-31的次序传送的，这个是**大端字节序列**，通常的OS都是**小端字节序列**，因此在发送到网络上之前，需要把头部转换成网络字节序列
3. TTL字段设置了IP数据报可以经过的最多路由器数，它指定了IP数据报的生存时间，初始值由源主机设置(32/64)，经过一个处理它的路由器，值就减1，当值为0时，就丢弃，然后通过ICMP报文通知源主机
4. 每个IP数据报都包括源IP地址和目标IP地址

# 3. IP路由选择
1. 如果目标主机和源主机直接相连，则IP数据报就直接送到目标主机，否则源主机把IP数据报发送到任一默认的路由器上，由路由器来转发该数据报
2. IP层既可以配置成路由器的功能，也可以配置成主机的功能；区别在于：**主机从不把数据报从一个端口转发到另外一个端口，而路由器则需要转发数据报**；内含路由器功能的主机应该从不转发数据报，除非它被设置成那样
3. IP层在内存中有一个路由表，当收到一份数据报并进行发送时，都要对该表搜索一次。当数据报来自某个网络接口时，IP先检查目的IP地址是否是本机的IP地址之一，或者IP广播地址，如果确实是这样，**数据报就会被送到由IP头部协议所指定的协议模块进行处理**；如果数据报的目的不是这些地址，那么a.如果IP层被设置为路由器功能，就对IP数据报进行转发；否则b.数据报被丢弃

# 4. 路由表信息
路由表中的每一项都包含以下信息：    
1. 目的IP地址===>最终目的地
2. 下一条路由器的IP地址
3. 标志，指明地址是网络地址还是主机地址
4. 为数据报传输指定一个网络接口

IP路由选择是逐跳进行的，从路由表信息来看，**它并不知道到达任何目的地的完整路径**，所有的IP路由选择只为数据报传输提供下一站路由器的IP地址，**它假定下一站路由器比发送数据报的主机更接近目的地**    
IP路由选择完成以下功能：    
1. 搜索路由表，寻找能与目的IP地址完全匹配的表目(网络号和主机号的都要匹配)，如果找到，则把IP报文发送到指定的路由器或则网络接口
2. 搜索路由表，寻找能与目的网络号匹配的表目，如果找到，则把IP报文发送到指定的路由器或则网络接口
3. 搜索路由表，寻找默认表目，如果找到，则把IP报文发送到指定的路由器
如果上面都没有成功，则数据报不能被传输，如果不能传送的数据报来自本机，则通常会向应用程序发送一个**主机不可达**或则**网络不可达**的错误

### 举例
数据报被送到以太网驱动程序，然后以太网数据帧被送到主机，通过ARP协议拿到48bit的以太网地址

# 5. 子网寻址
1. 现在网络不是单纯的分为了网络号+主机号，而是把主机号又分成了一个子网号+主机号==>原因**A，B类网络为主机号分配了太多的地址(全0/1的主机号无效)**      
2. 除了IP地址以外，主机还需要知道有多少个bit用于子网号，多少个bit用于主机号，**这就需要通过子网掩码来确定**     
3. 子网掩码是一个32bit的值，全1的留给网络号+子网号，0的比特留给主机号  
4. 给定IP地址和子网掩码以后，主机就可以确定IP数据报的目的是：a.本子网的主机 b.本网络中其它子网的主机 c.其他网络上的主机；根据本机的IP地址，可以得到是A/B/C哪类地址，网络号和子网号的分界线，根据掩码可以得到子网号和主机的分界线

------
# 6. ifconfig命令
在引导时运行，配置主机上的每个接口

------
# 7. netstat命令也提供系统上的接口信息

------
# 8. ICMP协议==>internet控制报文协议
1. 传递差错报文以及其他需要注意的信息，被IP层或者更高层协议(TCP/UDP)使用，一些ICMP报文还能把差错报文返回给用户程序==>**ICMP报文是在IP报文内部被传输的**
2. 类型字段和代码字段共同决定ICMP报文的类型==>**查询报文或者是差错报文**
> 在对差错报文处理时，不会再生成另外一个差错报文

## 8.1 不生成ICMP差错报文的情况
1. ICMP差错报文(ICMP查询报文可能会产生ICMP差错报文)
2. 目的地址是广播地址或多播地址(D类地址)的IP数据报
3. 作为链路层广播的数据报
4. 不是IP分片的第一片
5. 源地址不是单个主机的数据报==>**即源地址不能是零地址，环回地址，广播地址，多播地址等**
**以上规则主要是防止过去允许ICMP差错报文对广播分组影响所带来的广播风暴**      

## 8.2 ICMP地址掩码请求和应答
1. 用于无盘系统在引导过程中获取自己的子网掩码，系统广播它的ICMP请求报文

## 8.3 ICMP时间戳请求和应答
1. 允许系统向另一个系统查询当前时间，返回的值是UTC值，优点：返回的是毫秒值；缺点：通过其他的方法获得当时的日期

## 8.4 ICMP端口不可达
端口不可达报文是ICMP报文不可达报文中的一种，以此来看看ICMP差错报文中所附加的信息，使用UDP来查看它      
UDP的规则之一是：如果收到一份数据报而目的地端口于某个正在使用的进程不相符合，那么UDP返回一个ICMP不可达报文

### 例子
```
$ tftp
tftp> connect asb 8888 // 使用connect指定主机名和端口号
tftp> get temp.foo     // 试图获得一个文件
Transfer timed out     // 大约25s以后
tftp> quit

```
1. 输入get命令以后，一份UDP数据报就发送到asb主机的8888端口
2. 在UDP数据报发送到asb主机之前，要先发送一个ARP请求来确定它的硬件地址
3. 返回ARP应答
4. 发送UDP数据,一个ICMP端口不可达差错立即返回，然后重发了三次
> ICMP是网际层协议，**ICMP报文是在主机之间交换的，它不用目的端口号**，而每个UDP数据报则是**从一个特定的端口发送到另一个指定的端口(8888)**, UDP后面的数字代表**UDP数据报中的数据长度**
5. TCP和UDP都在它们头部的前8个字节中保存了**源端口号和目标端口号**

## 8.5 ping命令
1. 是一个命令(内核程序)，目的是为了测试另一台主机是否可达，该程序发送一份ICMP报文给主机，并等待返回ICMP回显应答
2. 通常，如果ping不同某台主机，就不能telnet和ssh到那台主机，因此可以用来定位问题出在哪里，ping还能测试往返时间，ping不是一个用户进程
3. ping程序把ICMP报文中的标识符字段设置成发送进程的ID，从而即使在同一台主机上同时运行多个ping程序实例，也可以正确返回
4. 通常ping中的第一个往返时间值都要比其他的大，这是由于目的地端的硬件地址不在ARP高速缓存中
5. ping利用ICMP回显请求和回显应答报文，而不用经过传输层(UDP/TCP)，一般在内核中实现ICMP的功能
6. ping还可以记录路由选项

## 8.6 traceroute
1. 尽管不能保证从源端发送到目的地端的两份连续的IP数据报具有相同的路由，但是多数情况下是一样的，traceroute可以看到IP数据报从一台主机传送到另一台主机所经过的路由
2. IP首部中留给选项的空间有限，不能存放当前大多数的路径，因此才有了traceroute命令，它使用ICMP报文和IP首部中的TTL字段(TTL最终成为一个跳站的计数器，经过一跳就减1，初始值为64)
3. 当路由器收到一份IP数据报，如果TTL字段为0或1，则路由器不转发该数据报，而是丢掉该报文，并且给信源机发送一份ICMP超时报文信息


# 1. IP地址分类
## A 类 ==> 0+7(网络号)+24(主机号)
0.xxx
## B 类 ==> 10+14(网络号)+16(主机号)
128.xxx
## C 类 ==> 110+21(网络号)+8(主机号)
192.xxx
## D 类 ==> 1110+28(多播组号)
224.xxx
## E 类 ==> 11110+27(保留)
240.xxx

3. 同样链路层需要接收IP/ARP/RARP传送的数据，因此它也需要在**以太网帧中头部加入一个标识符，来指明是谁给的数据，因此它也有一个16bit的协议类型域**

# 4. 交互
1. 许多应用程序都需要通过TCP/UDP传送数据，因此在传输层需要存入一个应用程序的标识符号，在TCP/UDP中用16bit的端口号来表示不同的应用程序，TCP/UDP把**源端口号和目标端口号分别保存在报文头部**
2. ICMP，TCP，UDP，IGMP都需要向IP传送数据，IP通过在头部中存入一个8bit的数值，来标明数据来自哪一种协议，这个称为协议域    
> 1==ICMP 2==IGMP 6==TCP 17==UDP


